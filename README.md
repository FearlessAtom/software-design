# 1. DRY
To keep the codebase clean and avoid unnecessary repetition, I structured the [Money](SoftwareDesignLab1/Classes/Money.cs) class with reusable methods and encapsulated logic effectively. Instead of duplicating conversion logic across multiple operations, I centralized it in the [ToDollars()](https://github.com/FearlessAtom/software-design/blob/lab1/SoftwareDesignLab1/Classes/Money.cs#L42-L45) method, ensuring consistency whenever currency values need to be converted. Additionally, [operator overloading](https://github.com/FearlessAtom/software-design/blob/lab1/SoftwareDesignLab1/Classes/Money.cs#L47-L83) (+, -, *, /) relies on the same conversion logic rather than repeating calculations. This approach simplifies maintenance and ensures that any changes to currency conversion affect all relevant operations uniformly.
# 2. KISS
The design of the system prioritizes simplicity and clarity. Class names like [Money](SoftwareDesignLab1/Classes/Money.cs), [Currency](SoftwareDesignLab1/Classes/Currency.cs), and [Product](SoftwareDesignLab1/Classes/Product.cs) clearly reflect their purpose, reducing confusion. Instead of overloading Money with responsibilities, it works alongside [Currency](SoftwareDesignLab1/Classes/Currency.cs), ensuring each class has a distinct role. The [arithmetic operations](https://github.com/FearlessAtom/software-design/blob/lab1/SoftwareDesignLab1/Classes/Number.cs#L46-L144) in class [Number](SoftwareDesignLab1/Classes/Number.cs) (+, -, *, /) follow a straightforward logic—values are converted to a common currency before performing calculations, making the process easy to follow.
# 3. SOLID
## 3.1 Single Responsibility Principle
Each class in the project serves a single purpose.
- [Number](SoftwareDesignLab1/Classes/Number.cs) – Represents numerical values and provides basic arithmetic operations.
- [Currency](SoftwareDesignLab1/Classes/Currency.cs) – Defines currency types and their properties, such as conversion rates and symbols.
- [Product](SoftwareDesignLab1/Classes/Product.cs) – Represents a generic product with attributes like price and name.
- [Money](SoftwareDesignLab1/Classes/Money.cs) – Encapsulates an amount and its associated currency.
- [Reporting](SoftwareDesignLab1/Classes/Reporting.cs) – Manages report generation.
- [Warehouse](SoftwareDesignLab1/Classes/Warehouse.cs) – Stores and tracks products.
## 3.2 Open/Closed Principle
The project structure allows easy extension of functionality without modifying existing code. For example, new products can be introduced by implementing the [IProduct](SoftwareDesignLab1/Interfaces/IProduct.cs) interface without altering existing logic. The system can support different types of products without modifying the code that processes them.  Similarly, new currencies can be added by implementing the [ICurrency](SoftwareDesignLab1/Interfaces/ICurrency.cs) interface without changing any code that handles monetary operations. Since the existing logic interacts with [ICurrency](SoftwareDesignLab1/Interfaces/ICurrency.cs) rather than specific currency implementations, the system remains flexible.
## 3.3 Liskov Substitution
In my code, [DiscountableProduct](SoftwareDesignLab1/Classes/DiscountableProduct.cs) extends [Product](SoftwareDesignLab1/Classes/Product.cs) while ensuring that it can seamlessly replace Product without affecting the correctness of the system. The core logic remains intact, regardless of whether a [Product](SoftwareDesignLab1/Classes/Product.cs) or a [DiscountableProduct](SoftwareDesignLab1/Classes/DiscountableProduct.cs) is used. Each class correctly upholds the expected behavior:
- [Product](SoftwareDesignLab1/Classes/Product.cs) establishes the fundamental attributes and pricing logic.
- [DiscountableProduct](SoftwareDesignLab1/Classes/DiscountableProduct.cs) enhances Product by adding discount functionality while still still being compatible with the original contract.
## 3.4 Interface Segregation Principle
The system is designed with specialized interfaces so that classes only implement the functionality they actually need. Instead of adding discount-related methods to [Product](SoftwareDesignLab1/Classes/Product.cs), I introduced the [IDiscountable](SoftwareDesignLab1/Interfaces/IDiscountable.cs) interface.
- [Product](SoftwareDesignLab1/Classes/Product.cs) remains a general representation of a product without any discount logic.
- [DiscountableProduct](SoftwareDesignLab1/Classes/DiscountableProduct.cs) extends Product but also implements IDiscountable, meaning only products that support discounts need to handle them.
## 3.5 Dependency Inversion Principle
The system relies on abstractions rather than concrete classes. [DiscountableProduct](SoftwareDesignLab1/Classes/DiscountableProduct.cs) extends Product and implements [IDiscoutable](SoftwareDesignLab1/Classes/IDiscountable.cs), but the code interacts with [IProduct](SoftwareDesignLab1/Interfaces/IProdutct.cs), ensuring flexibility. This allows new product types to be introduced without modifying existing functionality.
# 4. YAGNI
I designed the system to include only the features required for its current functionality. For example, the [Money](SoftwareDesignLab1/Classes/Money.cs) class handles basic currency management but doesn’t include unnecessary features like advanced conversion or rounding rules. Similarly, the [Warehouse](SoftwareDesignLab1/Classes/Warehouse.cs) class focuses on adding, removing, and tracking products without extra functionality like automated restocking or supplier management.
# 5. Composition over Inheritance
Instead of using inheritance, I designed the system by composing objects from smaller, independent components. The [Money](SoftwareDesignLab1/Classes/Money.cs) class, for example, does not inherit from [Number](SoftwareDesignLab1/Classes/Number.cs)  or [Currency](SoftwareDesignLab1/Classes/Currency.cs)  instead, it contains them as properties.
- [Money](SoftwareDesignLab1/Classes/Money.cs) holds a [Number instance](https://github.com/FearlessAtom/software-design/blob/lab1/SoftwareDesignLab1/Classes/Money.cs#L7) for storing amounts and an [ICurrency](SoftwareDesignLab1/Interfaces/ICurrency.cs) instance for handling different currencies.
- This separation allows [Money](SoftwareDesignLab1/Classes/Money.cs) to work with any currency type without being tightly coupled to a specific implementation.
- The logic for numeric operations remains in [Number](SoftwareDesignLab1/Classes/Number.cs), ensuring that [Money](SoftwareDesignLab1/Classes/Money.cs) focuses solely on representing monetary values.
# 6. Program to Interfaces not Implementations
The project is designed to depend on abstractions rather than concrete classes, promoting flexibility and scalability. Instead of a concrete [Product](SoftwareDesignLab1/Classes/Product.cs)  class, the system operates with the [IProduct](SoftwareDesignLab1/Interfaces/IProduct.cs)  interface, enabling seamless integration of new product types without altering existing logic. Similarly, the [ICurrency](SoftwareDesignLab1/Interfaces/ICurrency.cs)  interface defines the structure for currency-related operations, allowing different currency implementations to coexist without modifying the core system.
# 7. Fail Fast
To ensure system integrity and catch errors early, I applied the Fail Fast principle in the [Currency](SoftwareDesignLab1/Classes/Currency.cs) and [Number](SoftwareDesignLab1/Classes/Number.cs) classes by validating inputs upfront. In [Currency](SoftwareDesignLab1/Classes/Currency.cs), the [ToDollarRatio](https://github.com/FearlessAtom/software-design/blob/lab1/SoftwareDesignLab1/Classes/Currency.cs#L9-L25) property rejects negative values immediately, preventing invalid exchange rates. Similarly, [Number](SoftwareDesignLab1/Classes/Number.cs) enforces constraints on [WholePart](https://github.com/FearlessAtom/software-design/blob/lab1/SoftwareDesignLab1/Classes/Number.cs#L14-L22) and [FractionalPart](https://github.com/FearlessAtom/software-design/blob/lab1/SoftwareDesignLab1/Classes/Number.cs#L25-L35), rejecting negatives at entry to maintain consistency.
